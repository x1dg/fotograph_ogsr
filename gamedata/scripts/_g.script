--*********************************************************************************************************
--==============================================================================================
log1("--LUA version: ["..(jit.version or _VERSION).."]")
--==============================================================================================
FFI = require('ffi') --Делать только здесь и только один раз!
--==============================================================================================
math.randomseed(os.time())
--====================================[LuaFileSystem]===========================================
--lfs.dll должен быть в папке bin.
--xpcall(function() require("lfs") end, log1)
--=======================================[LuaXML]===============================================
--_luaxml.script должен быть в папке scripts.
--prefetch("_luaxml")
game_options.load_game_options()
--===================[string.lower и string.upper с поддержкой русских букв]====================
--[=[--KRodin: Из-за setlocale могут возникать проблемы.
os.setlocale("", "ctype") --Для старых версий LuaJIT достаточно установить правильную локаль.
if jit.version_num >= 20000 then --В новых версиях установки локали недостаточно
	FFI.cdef[[
		int tolower( int code );
		int toupper( int code );
	]]
	string.lower = function(s)
		return s:gsub('.', function(x)
			return string.char( FFI.C.tolower( x:byte() ) )
		end)
	end
	string.upper = function(s)
		return s:gsub('.', function(x)
			return string.char( FFI.C.toupper( x:byte() ) )
		end)
	end
end
--]=]
do
	local lower = string.lower
	string.lower = function(s)
		return lower(s:gsub("([А-Я])",function(c) return string.char(c:byte()+32) end):gsub("Ё", "ё"))
	end
	--
	local upper = string.upper
	string.upper = function(s)
		return upper(s:gsub("([а-я])",function(c) return string.char(c:byte()-32) end):gsub("ё", "Ё"))
	end
end
--=================================[Функции из xrLuaFix]========================================
--Cрезать первое "слово"
string.trim_w = function(s) return s:gsub("%s-(%S+)%s+", '', 1) end
--Срезать пробелы слева
string.trim_l = function(s) return s:gsub("^%s+", '') end
--Срезать пробелы справа
string.trim_r = function(s) return s:gsub("%s*$", '') end
--Срезать пробелы слева и справа
string.trim   = function(s) return s:match( "^%s*(.*%S)" ) or "" end
------------------------------------------------------------------------------------------------
--Возвращает кол-во элементов в таблице. Для массивов надо использовать оператор #.
table.size = function(t)
	local size = 0
	for _ in pairs(t) do size = size + 1 end
	return size
end
--Возвращает случайный элемент массива. Для обычных таблиц такое делать нет никакого смысла. В движке было сделано как-то странно.
table.random = function(t)
	return t[math.random(#t)]
end
--Возвращает массив с ключами таблицы
table.keys = function(t)
	local arr = {}
	for k, _ in pairs(t) do
		table.insert(arr, k)
	end
	return arr
end
--Возвращает массив с значениями таблицы
table.values = function(t)
	local arr = {}
	for _, v in pairs(t) do
		table.insert(arr, v)
	end
	return arr
end
--==============================================================================================
-- Взято из аддона Naxac'a
local to_ptrn = {
	[' '] = '%s',
	['.'] = '%.',
	['%'] = '%%',
	['*'] = '%*',
	['-'] = '%-'
}
string.explode = function( div,    -- разделитель
                           str,    -- строка
                           clear ) -- обрезать ли пробелы по краям строк (false/true)
	local ret = {}
	for s in str:gmatch("([^"..(to_ptrn[div] or div).."]+)") do
		ret[#ret+1] = (clear and s:trim() or s)
	end
	return ret
end
--==============================================================================================
-- очистка строки от "лишних" символов (полезно при работе с FS)
string.clear = function(str) --KRodin: поправил функцию, теперь работает.
	return str:gsub( '[/:<>|%*%?"\\]*', "" )
end
--==============================================================================================
-- Форматирование текста по ширине
-- http://www.amk-team.ru/forum/topic/13216-sborochnyy-ceh/?do=findComment&comment=959286
string.width = function(str, width, return_table, indent, paragrapf)
    indent    = indent    or 0
    paragrapf = paragrapf or 0
    width     = (width or 80) - indent

    local i = string.rep(' ', indent)
    local t = {}
    local line = string.rep(' ', paragrapf)

    for exp, word in str:gmatch('(%s-(%S+))') do
        if line == '' and #t ~= 0 then
            exp = word
        end

        local l_len = #line
        local len = l_len + #exp
        
        if len > width then
            t[#t+1], line = line, word
        else
            line = line .. exp
            if l_len == width then
                t[#t+1], line = line, ''
            end
        end
    end

    t[#t+1] = line

    if return_table then
        return t
    else
        return i .. table.concat(t, '\n' .. i)
    end
end
--==============================================================================================
function table.copy(tbl) --Возвращает копию таблицы.
	local mt = getmetatable(tbl)
	local res = {}
	for k, v in pairs(tbl) do
		if type(k) == "table" then
			k = table.copy(k)
		end
		if type(v) == "table" then
			v = table.copy(v)
		end
		res[k] = v
	end
	setmetatable(res, mt)
	return res
end
--=================================[CUIScriptWnd Extension]=====================================
-- Вызов обычный, как и в AddCallback, но после последнего аргумента можно передавать множество дополнительных.
function CUIScriptWnd:Connect(name, event, func, ...)
	local args = {...}
	return self:AddCallback( name, event, function() func(unpack(args)) end )
end
--==============================================================================================
local tostring_all_tbl = {
    ["table"] 	   = function(table, ind) --Распечатка таблиц
                        local res = "{" --Начало
                        local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
                        local def_ind = "  " --Отступ от начала строки
                        ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
                        for k, v in pairs(table) do
                            res = res.."\n"..ind.."["..tostring_all(k, ind).."] = "..tostring_all(v, ind)..","
                        end
                        return res..end_res
                    end,
    ["string"]    = function(v) return "'"..v.."'" end, --Строки берём в кавычки. Это нужно, чтобы можно было отличить строку "123" от числа 123, "nil" от nil и тд...
    ["number"]    = function(v) return tostring(v) end,
    ["boolean"]   = function(v) return tostring(v) end,
    ["nil"]       = function(v) return tostring(v) end,
    ["function"]  = function() return "[[FUNCTION]]" end, --Function, Userdata и Thread распечатать нельзя, просто заменим на строки
    ["userdata"]  = function() return "[[USERDATA]]" end,
    ["thread"]    = function() return "[[THREAD]]" end,
}
--Конвертирование чего угодно в строку. Использовать только для вывода в лог!
function tostring_all(obj, ind) --ind - служебный аргумент для распечатки "таблиц в таблицах".
	return tostring_all_tbl[type(obj)](obj, ind)
end

--Функциональная обёртка для log1.
--Делает дополнительную работу по конвертации параметров, которые не воспринимаются родной функцией string.format.
--Параметры можно передавать ЛЮБОГО ТИПА! В строке формата они должны стоять как %s (потому, что будут сконвертированы в строки).
function log3(fmt, ...)
	local args = {...}
	for i=1, #args do
		args[i] = tostring_all(args[i])
	end
	local res, msg = pcall(string.format, fmt, unpack(args))
	if not res then --Г…Г±Г«ГЁ ГЇГ°Г®ГЁГ§Г®ГёГ«Г  Г®ГёГЁГЎГЄГ 
		msg = "!!log3 failed: "..msg.."\n"..debug.traceback()
	end
	log1(msg)
end
--==============================================================================================
function abort(fmt, ...)
	log1("!!****************************[ABORT]*********************************")
	log1(debug.traceback())
	log3(fmt, ...)
	log1("!!********************************************************************")
	error(tostring(fmt))
end
function ASSERT(cond, ...)
	if not cond then
		abort(...)
	end
end
--==============================================================================================
function cmd(scmd, ...)
	ASSERT(scmd, "[cmd] scmd is a nil reference")
	local args = {...}
	if #args > 0 then
		scmd = scmd..' '..table.concat(args, ' ')
	end
	get_console():execute(scmd)
end
--==============================================================================================
log = function(...) --[[log1(...)]] end
--***************************************************************************************************************


schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

-- Загружает схему из файла на диске и активирует в мотиваторе.
-- Здесь:
-- 	filename - имя файла, в котором реализована схема, без расширения
-- 	scheme - имя схемы
function load_scheme(filename, scheme, stype)
	schemes[scheme] = filename
	stypes[scheme] = stype
end

----------------------------------------------------------------------

function printf(fmt,...)
	log(string.format(fmt,...))
end

----------------------------------------------------------------------
if nil == time_global then
	time_global = function () return device():time_global() end
end

function wait_game(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = game.time() + time_to_wait
        while game.time() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function wait(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = time_global() + time_to_wait
        while time_global() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

function action_first(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,true)
    end
    return  entity_action(act)
end

function round (value)
    local min = math.floor (value)
    local max = min + 1
    if value - min > max - value then return max end
    return min
end

function debug_get_level_object(obj_name)
    local res = level.debug_object(obj_name)
    while res == nil do

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!! НЕ ЗАКОММЕНТАРИВАЙТЕ, ИНАЧЕ НЕ БУДЕТ ВИДНО ОШИБОК ПРИ РАССТАНОВКЕ ОБЪЕКТОВ !!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        printf("get_level_object() is waiting for object \"%s\"", obj_name)

        res         = level.object(obj_name)
        wait        ()
    end
    return          res
end

function debug_get_actor()
    local res       = level.debug_actor()
    while res == nil do
        res         = level.debug_actor()
        wait        ()
    end
    return          res
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

// Если один объект nil, например нет актера, то считаем, что он далеко
function distance_between_safe(obj1, obj2)
    if(obj1 == nil or obj2 == nil) then return 100000 end
	return obj1:position():distance_to(obj2:position())
end


--' Проверка на инфопоршны, даже если игрока не существует
function has_alife_info(info_id)
	local aa = alife()
	if aa == nil then
		return false
	end
	return aa:has_info(0, info_id)
end


--------------------------------------------------
-- іласс LUA реализуі   ий Finite State Machine
-- для управления персонажами
--------------------------------------------------
class 'FSM'

--  инициализация путем задания объекта Non-Player Character
function FSM:__init(script_name, npc_obj)
    -- указатель на подконтрольнvй NPC
    self.npc = npc_obj
    -- строка - имя скрипта, которvй запускает игру
    self.script_name = script_name
    -- матрица, задаі   ая граф переходов состояний
    -- реализуется как двумерная таблица
    self.transition_matrix = {[0] = {}}
    -- номер теку   его состояния
    self.current_state = 0

    -- флаг того, что машина вклічена
    self.machine_running = true

    printf("inialization FSM for NPC %s", self.npc:name())
end

function FSM:is_running()
    return self.machine_running
end

function FSM:start()
    printf("starting FSM for %s", self.npc:name())
    self.machine_running = true
end

function FSM:stop()
    printf("stoping FSM for %s", self.npc:name())
    self.machine_running = false
    self:reset_script_control()
end


--  добавление указателя на булеву
--  ГґГіГ­ГЄГ¶ГЁВі ГіГ±Г«Г®ГўГЁГї ГЇГҐГ°ГҐГµГ®Г¤Г 
function FSM:set_transition(from_state_num, to_state_num, cond_func)
    printf("in setting transition %d, %d ", from_state_num, to_state_num)

    if self.transition_matrix[from_state_num] == nil then
       self.transition_matrix[from_state_num] = {[to_state_num] = cond_func}
    else
       self.transition_matrix[from_state_num][to_state_num] = cond_func
    end
end

-- единичная проверка FSM
function FSM:run()
    local transition_vector = self.transition_matrix[self.current_state]
    table.foreach(transition_vector,
                  function(to_state_num, cond_func)
                        if cond_func(self.npc, self) == true then
                            printf("transition from %d to %d", self.current_state, to_state_num)

                            if to_state_num == 0 then
                                self:reset_script_control()
                            end

                            --if  self.current_state == 0 then
                            --  self:set_script_control()
                            --end

                            self.current_state = to_state_num
                            return true
                        end
                        return nil
                  end)
end


-- запуск бесконечного цикла FSM
function FSM:run_loop()
    printf("running FSM loop for NPC %s", self.npc:name())

    while self:is_running() do
        local transition_vector = self.transition_matrix[self.current_state]
        table.foreach(transition_vector,
                      function(to_state_num, cond_func)
                            if cond_func(self.npc, self) == true then
                                printf("transition from %d to %d", self.current_state, to_state_num)

                                if to_state_num == 0 then
                                    self:reset_script_control()
                                end

                                --if  self.current_state == 0 then
                                --  self:set_script_control()
                                --end

                                self.current_state = to_state_num
                                return true
                            end
                            return nil
                      end)
        if self.npc:alive () == false then
           self.npc:script (false, self.script_name)
           return
           end
        wait()
    end
end

-- взятие под контроль скрипта NPC (переход из нулевого состояния)
function FSM:set_script_control()
    printf("set script control for FSM of NPC %s", self.npc:name())
    self.npc:script(true, self.script_name)
end

-- отпускание из под контроля скрипта NPC (переход в нулевое состояние)
function FSM:reset_script_control()
    printf("reset script control for FSM of NPC %s", self.npc:name())
    self.npc:script(false, self.script_name)
end

--------------------------------------------------
-- end of  class 'FSM'
--------------------------------------------------

function reset_action (npc, script_name)
    if npc:get_script () then
       npc:script (false, script_name)
    end
    npc:script (true, script_name)
end

class "script_object"

function script_object.__init(self,name,script,...)
	self.action         = action(nil,...)
	self.object_name    = name
	self.script_name    = script
	self.object         = nil
end

function script_object:update()
    local                   obj = self.object
    self.object             = level.object(self.object_name)
    if ((obj == nil) and (self.object ~= nil)) then
        self.object:script  (true,self.script_name)
        self.object:command (self.action,false)
    end
end

--
-- іередача персонажу информации
--

function GiveInfoViaPda(obj_receiver, obj_sender, info_number)
    obj_receiver:give_info_portion_via_pda(info_number, obj_sender)
end


--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------

-- іонстанта, которуі использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- =азвание скрипта, которvй в даннvй момент находится в отладке
-- (Гў ГЅГІГ®Г¬ Г±ГЄГ°ГЁГЇГІГҐ ГЎГіГ¤ГіГІ Г±Г°Г ГЎГ ГІvГўГ ГІГј ГўvГ§Г®Гўv ГґГіГ­ГЄГ¶ГЁГЁ debug_log)
debug_script_name = ""

-- Tvводит в лог строчку, если script_name == debug_script_name
-- Lспользуется для отрадки сценариев
function debug_log(script_name, fmt, ...)
	if debug_script_name == script_name then
		log(string.format(fmt, ...))
	end
end

-- +сли в даннvй момент вvполняется какое-то действие, прерvвает его и отклічает скриптовvй режим
function interrupt_action(who, script_name)
  if who:get_script() then
    who:script(false, script_name)
  end
end

function random_choice(...)
    local arg = {...}
    local r = math.random(1, table.getn(arg))
    return arg[r]
end

function new_action(...)
    local arg = {...}
    local act = entity_action()
    for i = 1, table.getn(arg) do
        act:set_action(arg[i])
    end
    return act;
end

obj_last_actions = {};

function perform_action(obj, action_name, action)
  if (obj ~= nil) then
    obj_last_actions[obj] = action_name
    obj:command(act, false)
  end
end

function last_action(obj)
  return obj_last_actions[obj]
end

function if_then_else(cond, if_true, if_false)
    if cond then
        return if_true
    end
    return if_false
end

function update_action (npc, script, ...)
    local arg = {...}
    if npc == nil then return end
    local act = npc:action ()
    if arg.n == 0 then return end

    if act == nil then act = entity_action () end

    for a = 1, arg.n, 1 do
        if arg[a] ~= nil then act:set_action (arg[a]) end
    end
    reset_action (npc, script)
    npc:command (act, false)

end


function set_current_time (hour, min, sec)
    local current_time_factor = level.get_time_factor ()

    printf ("Need time : %d:%d:%d", hour, min, sec)

    local current_time = game.time ()
    local c_day = math.floor (current_time / 86400000)
    local c_time = current_time - c_day * 86400000
    local n_time = (sec + min * 60 + hour * 3600) * 1000

    if c_time > n_time then c_day = c_day + 1 end
    n_time = n_time + c_day * 86400000

    level.set_time_factor (10000)
    while game.time () < n_time do wait () end

    level.set_time_factor (current_time_factor)
end



if (editor() == false) then
class "pp_effector" (effector)

function pp_effector:__init(effector_type,start_time,dest_power,life_time) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.max_power  = dest_power
end

function pp_effector:process(pp)
    effector.process(self,pp)

    local curr_time = time_global()
    local d         = 0.0

    if curr_time < self.start_time then
        d           = 0.0
    else
        if curr_time < self.stop_time then
            d           = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info   = self.max_power
            return      true
        end
    end

    local dual      = duality()
    local noise     = noise()
    local base      = color()
    local gray      = color()
    local add       = color()

    dual.h          = self.max_power.dual.h         * d
    dual.v          = self.max_power.dual.v         * d

    noise.grain     = self.max_power.noise.grain        * d
    noise.intensity     = self.max_power.noise.intensity    * d
    noise.fps       = self.max_power.noise.fps      * d

    base.r          = self.max_power.color_base.r       * d
    base.g          = self.max_power.color_base.g       * d
    base.b          = self.max_power.color_base.b       * d

    gray.r          = self.max_power.color_gray.r       * d
    gray.g          = self.max_power.color_gray.g       * d
    gray.b          = self.max_power.color_gray.b       * d

    add.r           = self.max_power.color_add.r        * d
    add.g           = self.max_power.color_add.g        * d
    add.b           = self.max_power.color_add.b        * d

    pp.gray         = self.max_power.gray           * d
    pp.blur         = self.max_power.blur           * d

    pp.dual         = dual
    pp.noise        = noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add

    self.info       = pp

    return              true
end

function pp_effector:finished()
    return          self.stop_time < time_global()
end

--
-- postprocess for rainbow
--
class "pp_linear_lerp" (effector)

function pp_linear_lerp:__init(effector_type,start_time,life_time,start_power,dest_power) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.min_power  = start_power
    self.max_power  = dest_power
end

function pp_linear_lerp:process(pp)
    effector.process(self,pp)

    local curr_time = time_global()
    local d         = 0.0

    if curr_time < self.start_time then
        d           = 0.0
    else
        if curr_time < self.stop_time then
            d           = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info   = self.max_power
            return      true
        end
    end

    local dual      = duality()
    local noise     = noise()
    local base      = color()
    local gray      = color()
    local add       = color()

    dual.h          = self.min_power.dual.h         + (self.max_power.dual.h        - self.min_power.dual.h     )   * d
    dual.v          = self.min_power.dual.v         + (self.max_power.dual.v        - self.min_power.dual.v     )   * d

    noise.grain     = self.min_power.noise.grain        + (self.max_power.noise.grain       - self.min_power.noise.grain    )   * d
    noise.intensity     = self.min_power.noise.intensity    + (self.max_power.noise.intensity   - self.min_power.noise.intensity)   * d
    noise.fps       = self.min_power.noise.fps      + (self.max_power.noise.fps         - self.min_power.noise.fps  )   * d

    base.r          = self.min_power.color_base.r       + (self.max_power.color_base.r      - self.min_power.color_base.r   )   * d
    base.g          = self.min_power.color_base.g       + (self.max_power.color_base.g      - self.min_power.color_base.g   )   * d
    base.b          = self.min_power.color_base.b       + (self.max_power.color_base.b      - self.min_power.color_base.b   )   * d

    gray.r          = self.min_power.color_gray.r       + (self.max_power.color_gray.r      - self.min_power.color_gray.r   )   * d
    gray.g          = self.min_power.color_gray.g       + (self.max_power.color_gray.g      - self.min_power.color_gray.g   )   * d
    gray.b          = self.min_power.color_gray.b       + (self.max_power.color_gray.b      - self.min_power.color_gray.b   )   * d

    add.r           = self.min_power.color_add.r        + (self.max_power.color_add.r       - self.min_power.color_add.r    )   * d
    add.g           = self.min_power.color_add.g        + (self.max_power.color_add.g       - self.min_power.color_add.g    )   * d
    add.b           = self.min_power.color_add.b        + (self.max_power.color_add.b       - self.min_power.color_add.b    )   * d

    pp.gray         = self.min_power.gray           + (self.max_power.gray          - self.min_power.gray       )   * d
    pp.blur         = self.min_power.blur           + (self.max_power.blur          - self.min_power.blur       )   * d

    pp.dual         = dual
    pp.noise        = noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add

    self.info       = pp

    return          true
end

function pp_linear_lerp:finished()
    return          self.stop_time < time_global()
end
--
-- end of postprocess for rainbow
--

----------------------------------------------------------------------------------------------------------------------
-- Evaluators
----------------------------------------------------------------------------------------------------------------------
-- Г§Г Г°ГҐГ§ГҐГ°ГўГЁГ°Г®ГўГ Г­v id Г± Г­Г®Г¬ГҐГ°Г Г¬ГЁ Г®ГІ 0 Г¤Г® 256 Г¤Г«Гї Г±Г®Г§Г¤Г Г­ГЁГї Г±ГІГ Г­Г¤Г Г°ГІГ­vГµ ГЅГўГ Г«ГіГ ГІГ®Г°Г®Гў.

--Constant evaluator
class "const_evaluator" (property_evaluator)

function const_evaluator:__init (name, value) super (nil, name)
    self.value = value
end

function const_evaluator:evaluate()
    return          self.value
end

--Wait evaluator
class "wait_evaluator" (property_evaluator)

function wait_evaluator:__init (wait_time) super ()
    self.wait_time = wait_time
    self.first_call = true
    self.current_time = 0
end

function wait_evaluator:evaluate ()
    if self.first_call == true then
       self.first_call = false
       self.current_time = device ():time_global ()
       return false
    end

    local t = device():time_global () - self.current_time;
    if t > self.wait_time then return true end
    return false
end
--------------------------------------------------------------------------------
class "enabled_evaluator" (property_evaluator)

function enabled_evaluator:__init (name, storage) super ()
    self.a = storage
end

function enabled_evaluator:evaluate()
    return  self.a.enabled
end

end -- end of editor() == false


function str_split (str)

    local strlen = string.len (str)

    local parts = {{}, {}, {}, {}}
    local cpart = 1

    for a = 1, strlen, 1 do
        local char = string.byte (str, a)
        if char ~= 95 then
           table.insert (parts[cpart], char)
        else
           cpart = cpart + 1
           if cpart > 4 then break end
        end
    end

    if cpart ~= 4 then return "unknown", "stalker", 0, 0 end

    local str1 = string.char ()
    local str2 = string.char ()
    local str3 = string.char ()
    local str4 = string.char ()

    local ref = parts[1]
    for a = 1, table.getn (ref), 1 do
        str1 = string.format ("%s%c", str1, ref[a])
    end

    ref = parts[2]
    for a = 1, table.getn (ref), 1 do
        str2 = string.format ("%s%c", str2, ref[a])
    end

    ref = parts[3]
    for a = 1, table.getn (ref), 1 do
        str3 = string.format ("%s%c", str3, ref[a])
    end

    ref = parts[4]
    for a = 1, table.getn (ref), 1 do
        str4 = string.format ("%s%c", str4, ref[a])
    end

    printf ("%s %s %d %d", str1, str2, str3, str4)
    return str1, str2, (str3 + 1) - 1, (str4 + 1) - 1
end

function random_number (min_value, max_value)
    math.randomseed (device ():time_global ())
    if min_value == nil and max_value == nil then
      return math.random ()
    else
      return math.random (min_value, max_value)
    end
end

-- ‚аҐ¬п бгв®Є ў ¬б
-- —гЈ ©
local ms_per_day = 24 * 60 * 60 * 1000
function day_time()
    return math.mod( game.time(), ms_per_day )
end

--Time in hours
function local_hours()
    return math.floor( math.mod( game.time()/1000, 86400 )/ 3600 )
end

-- ВЇВ Г ГЎВЁГў ГЎГўГ В®ВЄГЈ ВўВЁВ¤В  "В В В , ВЎВЎВЎ, ВўВўВў..." Вў ГўВ ВЎВ«ВЁГ¦ГЈ { "В В В ", "ВЎВЎВЎ", "ВўВўВў", ... }
-- вЂ”ГЈВЈВ В©
function parse_names( s )
    local t = {}
    for name in string.gfind( s, "([%w_\\]+)%p*" ) do
    --for name in string.gfind( s, "%s*([^%,]+)%s*" ) do
        table.insert( t, name )
    end

    return t
end


function parse_key_value( s )
    local t = {}
	if s == nil then
		return nil
	end
    local key, nam = nil, nil
    for name in string.gfind( s, "([%w_\\]+)%p*" ) do
		if key == nil then
			key = name
		else
			t[key] = name
			key = nil
		end
    end
    return t
end


-- ВЇВ Г ГЎВЁГў ГЎГўГ В®ВЄГЈ ВўВЁВ¤В  "n1, n2, n3..." Вў ГўВ ВЎВ«ВЁГ¦ГЈ { n1, n2, n3, ... } ВЈВ¤ВҐ n1, n2, n3... - Г¦ВҐВ«Г«ВҐ Г§ВЁГЎВ«В 
-- вЂ”ГЈВЈВ В©
--[[function parse_nums( s )
    local t = {}

    for entry in string.gfind( s, "([%w_\\]+)%p*" ) do
        table.insert( t, tonumber( entry ) )
    end

    return t
end]]

-- ВЇВ Г ГЎВЁГў ГЎГўГ В®ВЄГЈ ВўВЁВ¤В  "n1, n2, n3..." Вў ГўВ ВЎВ«ВЁГ¦ГЈ { n1, n2, n3, ... } ВЈВ¤ВҐ n1, n2, n3... - В¤Г В®ВЎВ­Г«ВҐ Г§ВЁГЎВ«В 
function parse_nums( s )
	local t = {}

	for entry in string.gfind( s, "([%d%.]+)%,*" ) do
		table.insert( t, tonumber( entry ) )
	end

	return t
end

-- Їа®ўҐапҐв, Ґбвм «Ё ®ЎкҐЄв ў ®­« ©­Ґ
function is_object_online(obj_id)
	return level.object_by_id(obj_id) ~= nil
end

function get_clsid(npc)
    if npc == nil then return nil end

	return npc:clsid()

--    if is_object_online(npc:id()) then
--      return npc:clsid()
--    else
--        return nil
--    end
end

-- Їа®ўҐапҐв ®аг¦ЁҐ «Ё нв® (ЇҐаҐ¤ ў вм game_object)
function isWeapon(object)
    local id = get_clsid(object)
    if id == nil then return false end

    if id == clsid.wpn_vintorez_s then return true
    elseif id == clsid.wpn_ak74_s then return true
    elseif id == clsid.wpn_lr300_s then return true
    elseif id == clsid.wpn_hpsa_s then return true
    elseif id == clsid.wpn_shotgun_s then return true
    elseif id == clsid.wpn_bm16_s then return true
    elseif id == clsid.wpn_svd_s then return true
    elseif id == clsid.wpn_svu_s then return true
    elseif id == clsid.wpn_rpg7_s then return true
    elseif id == clsid.wpn_val_s then return true
    elseif id == clsid.wpn_walther_s then return true
    elseif id == clsid.wpn_usp45_s then return true
    elseif id == clsid.wpn_groza_s then return true
    elseif id == clsid.wpn_knife_s then return true
    elseif id == clsid.wpn_grenade_launcher then return true
    elseif id == clsid.wpn_grenade_f1 then return true
    elseif id == clsid.wpn_grenade_rpg7 then return true
    elseif id == clsid.wpn_grenade_rgd5 then return true
    elseif id == clsid.wpn_grenade_fake then return true
    else return false end
end

--Tvчисляет yaw в радианах
function yaw( v1, v2 )
    return  math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) )
end

function yaw_degree( v1, v2 )
    return  (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) ) * 57.2957)
end
function yaw_degree3d( v1, v2 )
    return  (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/(math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross (v1, v2)
    return vector ():set (v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

//Вращает вектор вокруг оси y против часовой стрелки

function vector_rotate_y (v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

-- очистка таблицы
function clear_table (t)
    while table.getn (t) > 0 do
          table.remove (t, table.getn (t))
    end
end

--€бЇ®«м§гҐв ¤«п ¬®­бва®ў. ‚лЎ®а в®зЄЁ, Єг¤  Ё¤вЁ ў ­ҐЄ®в®а®¬ а ¤ЁгбҐ Ё зв®Ў в®зЄ  Ўл«  ¤ «миҐ ­  а ббв®п­ЁЁ
-- min_radius ®в вҐЄгйҐ© Ї®§ЁжЁЁ(Ґб«Ё нв® Ї®«гзЁвбп). center_id - жҐ­ва Ї®§ЁжЁЁ, ў®ЄагЈ Є®в®а®© ¦ЁўҐ¬,
-- position_id - вгЄгй п Ї®§ЁжЁп, radius - ў Є Є®¬ а ¤ЁгбҐ ўлЎЁа вм в®зЄг, min_radius - ¬Ё­Ё¬ «м­®Ґ а ббв®п­ЁҐ, ®в вҐЄгйҐ© Ї®§ЁжЁЁ ¤® ­®ў®© в®зЄЁ.
function new_point(center_id, position_id,radius, min_radius)
    local dir = vector():set(math.random(-1000, 1000)/1000.0, 0.0001, math.random(-1000, 1000)/1000.0)
    local pos = level.vertex_in_direction(center_id, dir, radius)
    local i   = 1

    while(level.vertex_position(position_id):distance_to(level.vertex_position(pos) ) < min_radius and i < 20) do
        dir = vector():set(math.random(-1000, 1000)/1000.0, 0.0001, math.random(-1000, 1000)/1000.0)
        pos = level.vertex_in_direction(center_id, dir, radius)
        i   = i + 1
    end

    return (level.vertex_position(pos))
end

function stop_play_sound(obj)
	if obj:alive() == true then
		obj:set_sound_mask(-1)
		obj:set_sound_mask(0)
	end
end

function object_type(obj)
    local otype = get_clsid(obj)
    local type

    if  otype == clsid.actor or
        otype == clsid.script_stalker or
        otype == clsid.script_trader
    then
        type = "stalker"
    elseif  otype == clsid.crow or
        otype == clsid.zombie or
        otype == clsid.flesh or
        otype == clsid.controller or
        otype == clsid.bloodsucker or
        otype == clsid.burer or
        otype == clsid.chimera or
        otype == clsid.boar or
        otype == clsid.flesh_group or
        otype == clsid.dog_red or
        otype == clsid.dog_black or
        otype == clsid.pseudo_gigant
    then
        type = "monstr"
    elseif  otype == clsid.wpn_fn2000 or
        otype == clsid.wpn_ak74 or
        otype == clsid.wpn_lr300 or
        otype == clsid.wpn_hpsa or
        otype == clsid.wpn_pm or
        otype == clsid.wpn_fort or
        otype == clsid.wpn_binocular or
        otype == clsid.wpn_shotgun or
        otype == clsid.wpn_svd or
        otype == clsid.wpn_svu or
        otype == clsid.wpn_rpg7 or
        otype == clsid.wpn_val or
        otype == clsid.wpn_vintorez or
        otype == clsid.wpn_walther or
        otype == clsid.wpn_usp45 or
        otype == clsid.wpn_groza or
        otype == clsid.wpn_knife or
        otype == clsid.wpn_scope or
        otype == clsid.wpn_silencer or
        otype == clsid.wpn_grenade_launcher or
        otype == clsid.obj_physic or
        otype == clsid.obj_breakable or
        otype == clsid.device_pda or
        otype == clsid.device_torch or
        otype == clsid.device_detector_simple or
        otype == clsid.obj_bolt or
        otype == clsid.obj_medkit or
        otype == clsid.obj_food or
        otype == clsid.obj_bottle or
        otype == clsid.obj_antirad or
        otype == clsid.obj_explosive or
        otype == clsid.obj_document or
        otype == clsid.obj_attachable or
        otype == clsid.wpn_grenade_f1 or
        otype == clsid.wpn_grenade_rpg7 or
        otype == clsid.wpn_grenade_rgd5 or
        otype == clsid.wpn_grenade_fake or
        otype == clsid.equ_scientific or
        otype == clsid.equ_stalker or
        otype == clsid.equ_military or
        otype == clsid.equ_exo or
        otype == clsid.wpn_ammo or
        otype == clsid.wpn_ammo_vog25 or
        otype == clsid.wpn_ammo_og7b or
        otype == clsid.wpn_ammo_m209
    then
        type = "item"
    else
        type = "none"
    end

    -- Їа®ўҐапҐ¬ ­Ґ вагЇ «Ё нв®
    if type == "stalker" or
       type == "monstr" then
        if obj:alive() == false then
            type = "corpse"
        end
    end

    return type
end


// Является ли оbj монстром
function is_object_monster(obj)
	local otype = get_clsid(obj)
	if(otype == clsid.crow			or
		otype == clsid.zombie		or
		otype == clsid.flesh		or
		otype == clsid.controller	or
		otype == clsid.bloodsucker	or
		otype == clsid.burer		or
		otype == clsid.chimera		or
		otype == clsid.boar			or
		otype == clsid.dog_red		or
		otype == clsid.dog_black	or
		otype == clsid.poltergeist	or
		otype == clsid.pseudo_gigant  )
	then
		return true
	end

	return false
end

--ў®§ўа й Ґв Їа®Ё§ў®«м­го в®зЄг ЇгвЁ г Є®в®а®© гбв ­®ў«Ґ­ ЎЁв
function point_with_bit(patrol_path, bit, old_point)      -- old_point - Ё­¤ҐЄб в®зЄЁ, Є®в®аго ­Ґ ­ ¤® ўлЎЁа вм,
  local points = {}                                       -- Ї а ¬Ґва ­Ґ ®Ўп§ вҐ«м­л©( ­ ЇаЁ¬Ґа вҐЄгйҐ© в®зЄЁ )

    for i = 0, patrol_path:count()-1 do
      --„®Ў®ў«пҐ¬ ў в Ў«Ёжг в®зЄЁ б ­г¦­л¬ ЎЁв®¬
      if( patrol_path:flag(i, bit)) then
            --„®Ў ў«пҐ¬ в®зЄг Ґб«Ё old_point == nil Ё«Ё ­®ў п в®зЄ  ­Ґ б®ўЇ ¤ Ґв б old_point
            if(old_point == nil) then
                table.insert(points, patrol_path:point(i))
            elseif(old_point ~= i) then
                table.insert(points, patrol_path:point(i))
            end
        end
    end

    local number_point = table.getn(points)

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return points[1]
    else
        return points[math.random(1, number_point)]
    end
end

--ў®§ўа й Ґв Їа®Ё§ў®«м­го в®зЄг ЇгвЁ г Є®в®а®© гбв ­®ў«Ґ­ ЎЁв
function point_with_bit_id(patrol_path, bit, old_point)        -- old_point - Ё­¤ҐЄб в®зЄЁ, Є®в®аго ­Ґ ­ ¤® ўлЎЁа вм,
    local points = {}                                          -- Ї а ¬Ґва ­Ґ ®Ўп§ вҐ«м­л©( ­ ЇаЁ¬Ґа вҐЄгйҐ© в®зЄЁ )

    for i = 0, patrol_path:count()-1 do
      --„®Ў®ў«пҐ¬ ў в Ў«Ёжг в®зЄЁ б ­г¦­л¬ ЎЁв®¬
      if( patrol_path:flag(i, bit)) then
            --„®Ў ў«пҐ¬ в®зЄг Ґб«Ё old_point == nil Ё«Ё ­®ў п в®зЄ  ­Ґ б®ўЇ ¤ Ґв б old_point
            if(old_point == nil) then
                table.insert(points, i)
            elseif(old_point ~= i) then
                table.insert(points, i)
            end
        end
    end

    local number_point = table.getn(points)

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return patrol_path:level_vertex_id(points[1])
    else
        return patrol_path:level_vertex_id(points[math.random(1, number_point)])
    end
end

--‚®§ўа й Ґв Ё­¤ҐЄб б ¬®© Ў«Ё¦­Ґ© в®зЄЁ ЇгвЁ б § ¤ ­л¬ ЎЁв®¬, ®в вҐЄгйҐ© в®зЄЁ
function near_point_with_bit(point, patrol_path, bit)
    local new_point = nil
    local index     = nil
    local dist      = 1000.0

    for i = 0, patrol_path:count()-1 do
        if( patrol_path:flag(i, bit) ) then
            if(new_point == nil or patrol_path:point(i):distance_to(point) < dist) then
                --…б«Ё нв  в®зЄ  ЇҐаў п Ё§ ­ иҐ¤иЁебп, «ЁЎ® ®в ­ҐҐ Їгвм Ў«Ё¦Ґ, в® § Ї®¬Ё­ Ґ¬ ҐҐ
                new_point   = patrol_path:point(i)
                index       = i
                dist        = new_point:distance_to(point)
             end
        end
    end

    return index
end

-- ђҐЄгабЁў­ п а бЇҐз вЄ  в Ў«Ёжл
function print_table(table, subs)
  local sub
  if subs ~= nil then
    sub = subs
  else
    sub = ""
  end
  for k,v in pairs(table) do
    if type(v) == "table" then
      printf(sub.."%s:", tostring(k))
      print_table(v, sub.."    ")
    elseif type(v) == "function" then
      printf(sub.."%s:function", tostring(k))
    elseif type(v) == "userdata" then
      printf(sub.."%s:userdata", tostring(k))
    elseif type(v) == "boolean" then
	if v == true then
		printf(sub.."%s:true", tostring(k))
	else
		printf(sub.."%s:false", tostring(k))
	end
    else
      if v ~= nil then
        printf(sub.."%s:%s", tostring(k),v)
      else
        printf(sub.."%s:nil", tostring(k),v)
      end
    end
  end
end

-------------------------------------------------------------------------------------------
function switch_online (id)
    if id == -1 then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (id, true)
       sim:set_switch_offline (id, false)
    end
end
-------------------------------------------------------------------------------------------
function switch_offline (npc)
    if npc == nil or npc:alive () == false then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (npc:id (), false)
       sim:set_switch_offline (npc:id (), true)
    end
end
-------------------------------------------------------------------------------------------
function get_actor_id()
	if(level.actor() == nil) then return -1 end
	return level.actor():id()
end
-------------------------------------------------------------------------------------------
function IsMonster (object, class_id)
    local id = class_id or get_clsid (object)
    if id == clsid.boar_s or
       id == clsid.bloodsucker_s or
       id == clsid.dog_s or
       id == clsid.flesh_s or
       id == clsid.pseudodog_s or
       id == clsid.psy_dog_s or
       id == clsid.burer_s or
       id == clsid.cat_s or
       id == clsid.chimera_s or
       id == clsid.controller_s or
       id == clsid.fracture_s or
       id == clsid.poltergeist_s or
       id == clsid.gigant_s or
       id == clsid.zombie_s or
       id == clsid.tushkano_s or
       id == clsid.snork_s
    then
	    return true
	end
    return false
end
-------------------------------------------------------------------------------------------
function IsStalker (object, class_id)
    local id = class_id or get_clsid (object)
    if id == clsid.actor or id == clsid.script_stalker then
       return true
    end
    return false
end
-------------------------------------------------------------------------------------------
function level_object_by_sid( sid )
	local sim = alife()

	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return level.object_by_id( se_obj.id )
		end
	end

	return nil
end

function id_by_sid( sid )
	local sim = alife()

	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return se_obj.id
		end
	end

	return nil
end

function set_postprocess(name_ini_file)
	bind_stalker.post_process = postprocess.PostProcess(ini_file(name_ini_file))
end
function remove_postprocess()
	bind_stalker.post_process = nil
end

function set_inactivate_input_time(delta)
	db.storage[db.actor:id()].disable_input_time = game.get_game_time()
	db.storage[db.actor:id()].disable_input_idle = delta
	level.disable_input()
end
-- Принимает: позицию положения, позицию куда смотреть, время сна в минутах.
function set_sleep_relocate(point, look, timeout)
	db.storage[db.actor:id()].sleep_relocate_time = game.get_game_time()
	db.storage[db.actor:id()].sleep_relocate_idle = timeout*60
	db.storage[db.actor:id()].sleep_relocate_point = point
	db.storage[db.actor:id()].sleep_relocate_look = look

	--set_inactivate_input_time(timeout*60)
	--db.actor:actor_sleep(0, timeout)
end

-- проверяет целую часть числа на нечётность
function odd( x )
	return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

--' Усталость
function on_actor_critical_power()
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial("part_11_weakness")
	end
	if not has_alife_info("encyclopedy_tutorial_weakness") then
		db.actor:give_info_portion("encyclopedy_tutorial_weakness")
	end
end

function on_actor_critical_max_power()
end

--' Кровотечение
function on_actor_bleeding()
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial("part_8_wound")
	end
	if not has_alife_info("encyclopedy_tutorial_wound") then
		db.actor:give_info_portion("encyclopedy_tutorial_wound")
	end
end

function on_actor_satiety()
end

--' Радиация
function on_actor_radiation()
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial("part_6_radiation")
	end
	if not has_alife_info("encyclopedy_tutorial_radiation") then
		db.actor:give_info_portion("encyclopedy_tutorial_radiation")
	end
end

--' Заклинило оружие
function on_actor_weapon_jammed()
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial("part_9_weapon")
	end
	if not has_alife_info("encyclopedy_tutorial_weapon") then
		db.actor:give_info_portion("encyclopedy_tutorial_weapon")
	end
end

--' не может ходить изза веса
function on_actor_cant_walk_weight()
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial("part_14_overload")
	end
	if not has_alife_info("encyclopedy_tutorial_overload") then
		db.actor:give_info_portion("encyclopedy_tutorial_overload")
	end
end

--' пси воздействие
function on_actor_psy()
end

function set_actor_rank(rank)
	if rank == "novice" then
		db.actor:set_character_rank(0)
	elseif rank == "stalker" then
		db.actor:set_character_rank(300)
	elseif rank == "veteran" then
		db.actor:set_character_rank(600)
	elseif rank == "master" then
		db.actor:set_character_rank(900)
	end
end

function get_texture_info(id_name, id_default)
	if id_default == nil then id_default = id_name end

	local task_info = GetTextureInfo(id_name, id_default)
	local r = task_info:get_rect()

	r.x2 = r.x2 - r.x1
	r.y2 = r.y2 - r.y1
	return task_info:get_file_name(), r
end

function start_game_callback()
	--
	m_netpk.attach()
	--
	task_manager.clear_task_manager()
	treasure_manager.clear_treasure_manager()
	xr_sound.clear_all_sound_object()
	dialog_manager.fill_phrase_table()	
end

ammo_section = {}
ammo_section["ammo_9x18_fmj"]		= true
ammo_section["ammo_9x18_pbp"]		= true
ammo_section["ammo_9x18_pmm"]		= true
ammo_section["ammo_9x19_fmj"]		= true
ammo_section["ammo_9x19_pbp"]		= true
ammo_section["ammo_5.45x39_fmj"]	= true
ammo_section["ammo_5.45x39_ap"]		= true
ammo_section["ammo_5.56x45_ss190"]	= true
ammo_section["ammo_5.56x45_ap"]		= true
ammo_section["ammo_5.7x28_fmj"]		= true
ammo_section["ammo_5.7x28_ap"]		= true
ammo_section["ammo_7.62x54_7h1"]	= true
ammo_section["ammo_7.62x54_ap"]		= true
ammo_section["ammo_7.62x54_7h14"]	= true
ammo_section["ammo_9x39_pab9"]		= true
ammo_section["ammo_gauss"]			= true
ammo_section["ammo_9x39_ap"]		= true
ammo_section["ammo_9x39_sp5"]		= true
ammo_section["ammo_11.43x23_fmj"]	= true
ammo_section["ammo_11.43x23_hydro"]	= true
ammo_section["ammo_12x70_buck"]		= true
ammo_section["ammo_12x76_dart"]		= true
ammo_section["ammo_12x76_zhekan"]	= true

quest_section = {}
quest_section["gunslinger_flash"]	= true
quest_section["af_blood_tutorial"]	= true
quest_section["esc_wounded_flash"]	= true
quest_section["quest_case_02"]		= true
quest_section["dar_document1"]		= true
quest_section["dar_document2"]		= true
quest_section["dar_document3"]		= true
quest_section["dar_document4"]		= true
quest_section["dar_document5"]		= true
quest_section["kruglov_flash"]		= true
quest_section["lab_x16_documents"]	= true
quest_section["good_psy_helmet"]	= true
quest_section["bad_psy_helmet"]		= true
quest_section["decoder"]			= true
quest_section["dynamite"]			= true
quest_section["quest_case_01"]		= true
quest_section["hunters_toz"]		= true
quest_section["bar_ecolog_flash"]	= true
quest_section["bar_tiran_pda"]		= true
quest_section["bar_lucky_pda"]		= true

-- служебные функции для чтения параметров из секций объектов
function get_string( section, param, def_val, ini_file )
  ASSERT(
    section,
    "get_string: section '%s' not defined, param = %s",
    tostring( section ), tostring( param )
  )
  local ini = ini_file or sys_ini
  ASSERT(
    ini:section_exist( section ),
    "get_string: section '%s' doesn't exist, param = %s",
    tostring( section ), tostring( param )
  )
  if ini:line_exist( section, param ) then
    return ini:r_string( section, param )
  else
    return def_val
  end
end


function get_string_wq( section, param, def_val, ini_file )
  ASSERT(
    section,
    "get_string_wq: section '%s' not defined, param = %s",
    tostring( section ), tostring( param )
  )
  local ini = ini_file or sys_ini
  ASSERT(
    ini:section_exist( section ),
    "get_string_wq: section '%s' doesn't exist, param = %s",
    tostring( section ), tostring( param )
  )
  if ini:line_exist( section, param ) then
    return ini:r_string_wq( section, param )
  else
    return def_val
  end
end


function get_u32( section, param, def_val, ini_file )
  ASSERT(
    section,
    "get_u32: section '%s' not defined, param = %s",
    tostring( section ), tostring( param )
  )
  local ini = ini_file or sys_ini
  ASSERT(
    ini:section_exist( section ),
    "get_u32: section '%s' doesn't exist, param = %s",
    tostring( section ), tostring( param )
  )
  if ini:line_exist( section, param ) then
    return ini:r_u32( section, param )
  else
    return def_val
  end
end


function get_bool( section, param, def_val, ini_file )
  ASSERT(
    section,
    "get_bool: section '%s' not defined, param = %s",
    tostring( section ), tostring( param )
  )
  local ini = ini_file or sys_ini
  ASSERT(
    ini:section_exist( section ),
    "get_bool: section '%s' doesn't exist, param = %s",
    tostring( section ), tostring( param )
  )
  if ini:line_exist( section, param ) then
    return ini:r_bool( section, param )
  else
    return not ( not def_val )
  end
end


function get_float( section, param, def_val, ini_file )
  ASSERT(
    section,
    "get_float: section '%s' not defined, param = %s",
    tostring( section ), tostring( param )
  )
  local ini = ini_file or sys_ini
  ASSERT(
    ini:section_exist( section ),
    "get_float: section '%s' doesn't exist, param = %s",
    tostring( section ), tostring( param )
  )
  if ini:line_exist( section, param ) then
    return ini:r_float( section, param )
  else
    return def_val
  end
end


-- получить класс из секции, полезно в том случае, если нет объекта (и недоступен метод clsid), а есть только имя секции
function get_class( section )
  ASSERT( section, "get_class: section parameter is not defined" )
  ASSERT(
    sys_ini:section_exist( section ),
    "get_class: section '%s' doesn't exist", tostring( section )
  )
  ASSERT(
    sys_ini:line_exist( section, "class" ),
    "get_class: there is no 'class' parameter in the section '%s'",
    tostring( section )
  )
  return sys_ini:r_clsid( section, "class" )
end


-- делит строку в виде "aaa,bbb,ccc" на строки "aaa", "bbb", "ccc" и возвращает
-- их в виде массива
function split_comma_separated_list( s )
  return string.explode( ",", s )
end


-- читает время, сохранённое в виде строки со значениями, разделёнными запятой, и конвертирует в значение класса CTime
function unpack_time_from_string(str_time)
	local time_values = {}
	for i,s in ipairs(split_comma_separated_list(str_time)) do
		local value = tonumber(s)
		ASSERT(value, "unpack_time_from_string: problem with unpacking saved time '%s', value #%d (%s)", str_time, i, tostring(s))
		table.insert(time_values, value)
	end
	ASSERT(#time_values == 7, "unpack_time_from_string: packed time '%s' has wrong number of components. Must be equal to seven.")
	local res = game.CTime()
	res:set(unpack(time_values))
	return res
end
-- упаковать время в виде объекта CTime в строку значений, разделённых запятой
function pack_time_to_string(t)
	ASSERT(t, "pack_time_to_string: t is a nil reference")
	return table.concat({t:get()}, ',')
end
-- читает строку вида "s1,s2,s3" и парсит на строковые значения, разделённые запятой, в таблицу вида {s1, s2, s3}
function get_names(section, param, ini_file)
	ASSERT(section, "get_names: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_names: section '"..section.."' doesn't exist")
	local s = ini:r_string(section, param)
	return split_comma_separated_list(s)
end
-- читает строку вида "s1,s2,s3" и парсит на численные значения, разделённые запятой, в таблицу вида {n1, n2, n3}
function get_numbers(section, param, ini_file)
	local t = {}
	for i,sv in ipairs(get_names(section, param, ini_file)) do
		local v = tonumber(sv)
		ASSERT(v, "get_numbers: can not convert to number item ["..i.."]: "..tostring(sv))
		table.insert(t, v)
	end
	return t
end

function get_section_keys( section, ini_file )
  local ini = ini_file or sys_ini
  ASSERT( ini:section_exist( section ), "get_section_keys: section '" .. section .. "' doesn't exist" )
  local t = {}
  for i = 0, ini:line_count( section ) - 1 do
    local _, key, v = ini:r_line( section, i )
      table.insert( t, key )
  end
  return t
end

function get_section_keys_and_values( section, ini_file )
  local ini = ini_file or sys_ini
  ASSERT( ini:section_exist( section ), "get_section_keys: section '" .. section .. "' doesn't exist" )
  local t = {}
  for i = 0, ini:line_count( section ) - 1 do
  local _, key, v = ini:r_line( section, i, "", "" )
    t[ key ] = v
  end
  return t
end

function get_vector(section, param, def_val, ini_file)
	ASSERT(section, "get_vector: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return vector():set(tonumber(pos[1]), tonumber(pos[2]), tonumber(pos[3]))
	else 
		if def_val then
			return def_val
		else
			return vector():set(0,0,0)
		end
	end
end

-- значение по умолчанию должно задаваться таблицей {num1, num2}
function get_vector2(section, param, def_val, ini_file)
	ASSERT(section, "get_vector2: section not defined, param=%s", param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector2: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return tonumber(pos[1]), tonumber(pos[2])
	else
		return def_val and unpack(def_val)
	end
end

-- Берём параметры иконки из конфигов
function get_inventory_icon_rect(sect)
	if sect == nil or sect == "" or sect == "EMPTY" then
		return 0, 0, 0, 0
	end
	return 50*sys_ini:r_u32(sect, "inv_grid_x"), 50*sys_ini:r_u32(sect, "inv_grid_y"), 50*sys_ini:r_u32(sect, "inv_grid_width"), 50*sys_ini:r_u32(sect, "inv_grid_height")
end


-- получить номер локации по номеру глобального вертекса
function location_id_by_gvid( gvid )
  if gvid and game_graph():valid_vertex_id( gvid ) then
    return game_graph():vertex( gvid ):level_id()
  end
end


-- получить номер локации для клиентского объекта
function object_location_id( obj )
  return obj.level_id
end


function object_level_name( obj )
  return obj.level_name
end


function level_system_name_by_lid( lid )
  if lid then
    return alife():level_name( lid )
  end
end


function level_name_by_level_system_name( lname )
  return game.translate_string( lname )
end


-- системное имя уровня
function level_system_name_by_gvid( gvid )
  return level_system_name_by_lid( location_id_by_gvid( gvid ) )
end


-- Внятное имя уровня (не системное, а то, которое изображается на карте):
function level_name_by_gvid( gvid )
  return level_name_by_level_system_name( level_system_name_by_gvid( gvid ) )
end


--***********************************[Функции для вывода в лог]****************
-------------------------------------------------------------------------------
local tostring_all_tbl = {
	["table"] =		function(table, ind) --Распечатка таблиц
						local res = "{" --Начало
						local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
						local def_ind = "  " --Отступ от начала строки
						ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
						for k, v in pairs(table) do
							res = res.."\n"..ind.."["..tostring_all(k, ind).."] = "..tostring_all(v, ind)..","
						end
						return res..end_res
					end,
	["string"] =	function(v) return "'"..v.."'" end, --Строки берём в кавычки. Это нужно, чтобы можно было отличить строку "123" от числа 123, "nil" от nil и тд...
	["number"] =	function(v) return tostring(v) end,
	["boolean"] =	function(v) return tostring(v) end,
	["nil"] =		function(v) return tostring(v) end,
	["function"] =	function() return "[[FUNCTION]]" end, --Function, Userdata и Thread распечатать нельзя, просто заменим на строки
	["userdata"] =	function() return "[[USERDATA]]" end,
	["thread"] =	function() return "[[THREAD]]" end,
}

--Конвертирование чего угодно в строку. Использовать только для вывода в лог!
-- ind - служебный аргумент для распечатки "таблиц в таблицах".
function tostring_all( obj, ind )
  ASSERT(
    tostring_all_tbl[ type( obj ) ],
    "unknown type %s", tostring( type( obj ) )
  )
  return tostring_all_tbl[ type( obj ) ]( obj, ind )
end

--Функциональная обёртка для log1.
--Делает дополнительную работу по конвертации параметров, которые не воспринимаются родной функцией string.format.
--Параметры можно передавать ЛЮБОГО ТИПА! В строке формата они должны стоять как %s (потому, что будут сконвертированы в строки).
function log3( fmt, ... )
  local t = {}
  for _, v in ipairs({ ... }) do
    table.insert( t, tostring_all( v ) )
  end
  local res, msg = pcall( string.format, fmt, unpack( t ) )
  if not res then -- Если произошла ошибка
    msg = "!!log3 failed: " .. msg .. "\n" .. debug.traceback()
  end
  log1( msg )
end

-----------------------------------------------------------------------------------------
-- Помогает определить, из за чего в некоторых случаях перезагружается _G
log1("--_G loaded from: "..debug.traceback())
-----------------------------------------------------------------------------------------
local logs_cach = {}
--Функция создаёт новый лог-файл и выводит текст в него.
--fname - название лог-файла, например "Anomaly_Evader". Он будет создан в папке logs, к названию добавится дата и время создания.
--fmt, ... - строка формата с параметрами как и в функции log3
function log4(fname, fmt, ...)
	local f = logs_cach[fname]
	if not f then
		local dt = os.date("*t")
		local fpath = getFS():update_path("$logs$", string.format("%s_%02d.%02d.%02d_%02d.%02d.%02d.log",fname,dt.day,dt.month,dt.year,dt.hour,dt.min,dt.sec))
		f = io.open(fpath, "w")
		logs_cach[fname] = f
	end
	local args = {...}
	for i=1, #args do
		args[i] = tostring_all(args[i])
	end
	local res, msg = pcall(string.format, fmt, unpack(args))
	if not res then
		msg = "!!log4 failed: "..msg.."\n"..debug.traceback()
	end
	f:write(msg..'\n')
	f:flush()
end
-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------
function log2(fmt, ...) --Простая обёртка для log1.
	log1(fmt:format(...))
end
-----------------------------------------------------------------------------------------
function clear_log() --Очистить лог
	cmd("clear_log")	
end
-----------------------------------------------------------------------------------------
--*****************************************************************************************************

function get_item_weight_by_section(section)
	local res = get_float(section, "inv_weight")
	ASSERT(res, "get_item_weight_by_section: there is no 'inv_weight' parameters in section '"..section.."'")
	return res
end

function get_ammo_weight_by_section(section, count)
	local box_weight = get_item_weight_by_section(section)
	local box_size = get_int(section, "box_size", 0)
	ASSERT(box_size > 0, "get_ammo_weight_by_section: 'box_size' parameters in section '"..section.."' is zero or missed")
	return box_weight * count / box_size
end

function print_vector(name, v)
	log1(string.format("%s: %9.3f, %9.3f, %9.3f", name, v.x, v.y, v.z))
end
function print_matrix(name, m)
	log1(name..":")
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.i.x, m.i.y, m.i.z, m._14_))
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.j.x, m.j.y, m.j.z, m._24_))
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.k.x, m.k.y, m.k.z, m._34_))
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.c.x, m.c.y, m.c.z, m._44_))
end
function time2string(time, fmt, order)
	ASSERT(time, "[_g.time2string] 'time' is a nil reference")
	if not fmt then
		return time:timeToString(game.CTime.TimeToMilisecs).." "..time:dateToString(game.CTime.DateToDay)
	else
		local y,m,d,h,min,s,ms = time:get()
		local args = {y=y,m=m,d=d,h=h,min=min,s=s,ms=ms,a=a,b=b}
		if order then
			args = {args[order[1]], args[order[2]], args[order[3]], args[order[4]], args[order[5]], args[order[6]], args[order[7]], args[order[8]], args[order[9]]}
		end
		return fmt:format(unpack(args))
	end
end
function print_time(title, time)
	log1(title..": "..time2string(time))
end


function hit_object(obj, dir, imp, dr, pow, t)
	local h = hit()
	h.direction = dir
	h.impulse = imp
    h.draftsman = dr
	h.power = pow
	h.type = t
	obj:hit(h)
end

function hit_object_ex(hit_params)
	local h = hit()
	ASSERT(hit_params.obj, "hit_object_ex: target is not defined! 'obj' field is a nil reference")
	h.direction = hit_params.dir or vector():set(1,0,0)
	h.impulse = hit_params.imp or 0
    h.draftsman = hit_params.dr or hit_params.obj
	h.power = hit_params.pow or 0
	h.type = hit_params.t or 0
	h.bone = hit_params.bone or ""
	hit_params.obj:hit(h)
end

--/Нанести хит

function hit_obj_by_id_simple(ObjId, Pwr, iImpulse)
	local obj2hit = level.object_by_id(ObjId)
	ASSERT(obj2hit, "[hit_obj_by_id_simple] no object found for id = %d", ObjId)
	local hit_params = {
		["t"] = hit.explosion, 
		["dir"] = vector():set(0, 0, 0),
		["dr"] = obj2hit,
		["obj"] = obj2hit,
		["imp"] = iImpulse,
		["pow"] = Pwr,
	}
	hit_object_ex(hit_params)
end


function seconds2ctime(time_sec)
	local s,ms = math.modf(time_sec)
	local t = game.CTime()
	t:setHMSms(0,0,s,ms*1000)
	return t
end

-- надёжнее, чем device().aspect_ratio, поскольку не зависит от инициализированности рендера
-- однако медленная. Не рекомендуется использовать часто
function get_aspect_ratio()
	local s =  get_console():get_string("vid_mode")
	local sw,sh = string.match(s, "(%d+)x(%d+)")
	return tonumber(sh)/tonumber(sw)
end


-- получение некоторых значений с плавающей запятой
-- параметры бега
function get_walk_accel()         return get_actor_obj().walk_accel end
function get_jump_speed()         return get_actor_obj().jump_speed end
function get_run_factor()         return get_actor_obj().run_coef end
function get_run_back_factor()    return get_actor_obj().run_back_coef end
function get_walk_back_factor()   return get_actor_obj().walk_back_coef end
function get_crouch_factor()      return get_actor_obj().crouch_coef end
function get_climb_factor()       return get_actor_obj().climb_coef end
function get_sprint_factor()      return get_actor_obj().sprint_koef end
function get_walk_strafe_factor() return get_actor_obj().walk_strafe_coef end
function get_run_strafe_factor()  return get_actor_obj().run_strafe_coef end
-- параметры стрельбы
function get_disp_base()          return get_actor_obj().disp_base end -- в радианах
function get_disp_aim()           return get_actor_obj().disp_aim end -- в радианах
function get_disp_vel_factor()    return get_actor_obj().disp_vel_factor end
function get_disp_accel_factor()  return get_actor_obj().disp_accel_factor end
function get_disp_crouch_factor() return get_actor_obj().disp_crouch_factor end
function get_disp_crouch_no_accel_factor()  return get_actor_obj().disp_crouch_no_acc_factor end
-- получение некоторых целых и логических значений
-- режим прицеливания
function zoom_mode() return db.actor:zoom_mode() end -- возвращает true/false

-- установка некоторых значений
-- параметры бега
function set_sprint_factor(v)      get_actor_obj().sprint_koef = v end
function set_jump_speed(v)         get_actor_obj().jump_speed = v end
function set_walk_accel(v)         get_actor_obj().walk_accel = v end
function set_run_factor(v)         get_actor_obj().run_coef = v end
function set_run_back_factor(v)    get_actor_obj().run_back_coef = v end
function set_walk_back_factor(v)   get_actor_obj().walk_back_coef = v end
function set_crouch_factor(v)      get_actor_obj().crouch_coef = v end
function set_climb_factor(v)       get_actor_obj().climb_coef = v end
function set_walk_strafe_factor(v) get_actor_obj().walk_strafe_coef = v end
function set_run_strafe_factor(v)  get_actor_obj().run_strafe_coef = v end
-- параметры стрельбы
function set_disp_base(v)          get_actor_obj().disp_base = v end -- в радианах
function set_disp_aim( v )         get_actor_obj().disp_aim = v end

function set_jump_power( v )
  get_actor_obj().condition.jump_power = v
end
function set_jump_weight_power( v )
  get_actor_obj().condition.jump_weight_power = v
end
function set_overweight_jump_k( v )
  get_actor_obj().condition.overweight_jump_k = v
end

function set_stand_power( v )
  get_actor_obj().condition.stand_power = v
end
function set_walk_power( v )
  get_actor_obj().condition.walk_power = v
end
function set_walk_weight_power( v )
  get_actor_obj().condition.walk_weight_power = v
end
function set_overweight_walk_k( v )
  get_actor_obj().condition.overweight_walk_k = v
end

function get_actor_power_max()
  return db.actor.conditions.power_max
end
function set_actor_power_max( v )
  db.actor.conditions.power_max = v
end


local body_states = { -- флажки состояния тела актора
[1]		= "fwd",
[2]		= "back",
[4]		= "l_strafe",
[8]		= "r_strafe",
[16]	= "crouch",
[32]	= "accel",
[64]	= "turn",
[128]	= "jump",
[256]	= "fall",
[512]	= "landing",
[1024]	= "landing2",
[2048]	= "climb",
[4096]	= "sprint",
[8192]	= "l_lookout",
[16384]	= "r_lookout"
}
-- получения флагов состояния тела актора
function actor_body_state()
  local body_state = body_states[ get_actor_obj():get_body_state() ]
  if body_state then
    return body_state
  else
    return ""
  end
end


-- установка невидимости сталкера со стороны аномалий
function set_anomaly_invisibility( npc, vis )
  npc:get_custom_monster().visible_for_zones = not vis
end

-- получение статуса невидимости сталкера со стороны аномалий
function get_anomaly_invisibility( npc )
  return not npc:get_custom_monster().visible_for_zones
end


function get_day_time_sec(t)
	local y,m,d,h,min,s,ms = t:get()
	return h * 3600.0 + min * 60.0 + s + ms * 1e-3
end

-- получить текушее игровое время от начала суток, измеренное в часах (значение в пределах [0, 24) )
function get_game_day_time_h()
	local gt = game.get_game_time()
	local y,m,d,h,min,sec,ms = gt:get()
	return math.fmod(h + min/60.0 + (sec + 0.001*ms)/3600.0, 24.0)
end

function is_16_9_mode()
	local dev = device()
	return dev.width / dev.height > 1.34
end
-- вернуть значение v, ограниченное сверху и снизу значениями l и u
function math.clamp(v, l, u)
	if v < l then 
		return l
	elseif v > u then 
		return u
	end
	return v
end
-- округление к ближайшему
function math.round(v)
	return math.floor(v + 0.5)
end

function math.lerp(x1, x2, y1, y2, x)
	return (x - x1) * (y2 - y1) / (x2 - x1)
end

function math.similar(a1, a2, tol)
	return math.abs(a1 - a2) <= tol
end


-- обнуление всех эффектов съедаемого предмета
-- изменённые значения в сейве не сохраняются
-- функция предназначена в основном для использования в событии предиспользования,
-- когда эффекты предмета ещё не применены и их можно изменить, что повлияет на собственно эффект от 
-- предмета на параметры здоровья, радиации и т.п.. При этом подразумевается,
-- что предмет после использования будет удалён, поэтому вопрос о сохранении этих свойств не стоит
-- если используется подход с eat_portions_num > 1 (обычно задаётся "бесконечное" значение, типа 10000),
-- то эту функцию либо использовать нельзя, либо надо таким же образом восстанавливать свойства предмета
-- в событии использования (стандартный колбек callback.use, который в сущности является колбеком на 
-- "послеиспользование", когда эффекты предмета уже применены)
function zero_all_item_effects( item )
  ASSERT( item:is_eatable_item(), "" )
  item:zero_effects()
end


-- установка направления взгляда актора в заданную точку
function actor_look_at_point( target_point )
  ASSERT(
    target_point, "actor_look_at_point: target point vector is a nil reference!"
  )
  local look_dir = vector():sub( target_point, device().cam_pos )
  local cam      = actor_camera( 0 )
  if cam then
    cam.yaw   = -look_dir:getH()
    cam.pitch = -look_dir:getP()
  end
end


local con = get_console()
function cmd(scmd, ...)
	ASSERT(scmd, "[cmd] scmd is a nil reference")
	local args = {...}
	if #args ~= 0 then
		scmd = scmd..' '..table.concat(args, ' ')
	end
	con:execute(scmd)
end
function get_con_float(param)
	return con:get_float(param)
end
function get_con_string(param)
	return con:get_string(param)
end
function get_con_bool(param)
	return con:get_bool(param)
end

-- проверка сушествования файла на диске
-- примечания: 
-- 1. это  для проверки существования реального файла, не в архиве
-- 2. способ неуклюжий, но другого в чистом Lua нет
function file_exists(name)
	local f = io.open(name,"r")
	if f then
		f:close()
		return true
	end
	return false
end


function set_item_untakeable( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FCanTake, false )
  item:set_inventory_item_flags( f )
end

function set_item_takeable( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FCanTake, true )
  item:set_inventory_item_flags( f )
end

function mark_grenade_non_pickable( obj )
  if obj:parent() then
    local timeout = time_global() + 10000
    obj:set_fastcall(
      function ( obj )
        if obj:parent() then
          if timeout < time_global() then
            log3(
              "[mark_grenade_non_pickable]: %s still has parent %s",
              obj:name(), obj:parent():name()
            )
            return true
          end
          return false
        else
          set_item_untakeable( obj )
          return true
        end
      end,
      obj
    )
  else
    set_item_untakeable( obj )
  end
end


-- сделать предмет безусловно негруппируемым в окнах инвентаря
function set_item_ungroupable( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIUngroupable, true )
  item:set_inventory_item_flags( f )
end

-- включить движковую группировку для предмета
function set_item_default_grouping( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIUngroupable, false )
  item:set_inventory_item_flags( f )
end

-- сделать предмет безусловно непродаваемым, будет показан красным. Для
-- избежания глюков надо также выключать группируемость для этого предмета.
function set_item_always_untradable( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIAlwaysUntradable, true )
  item:set_inventory_item_flags( f )
end

-- убрать принудительную неторгуемость и негруппирумость и оставить только
-- движковый алгоритм
function set_item_default_tradability( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIAlwaysUntradable, false )
  item:set_inventory_item_flags( f )
end

-- сделать предмет невидимым в инвентаре
function set_item_inv_hidden( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIHiddenForInventory, true )
  item:set_inventory_item_flags( f )
end

-- сделать его обратно видимым
function set_item_inv_visible( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIHiddenForInventory, false )
  item:set_inventory_item_flags( f )
end

-- Покрасить предмет в окнах обыска тайников/трупов в зелёный цвет
function set_item_always_highlighting( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIAlwaysHighlighted, true )
  item:set_inventory_item_flags( f )
end

-- использовать только движковую раскраску
function set_item_default_highlighting( item )
  local f = item:get_inventory_item_flags()
  f:set( global_flags.FIAlwaysHighlighted, false )
  item:set_inventory_item_flags( f )
end


function need_show_condition(item)
	local b = sys_ini:r_bool(item:section(), "show_condition", nil)
	return ( ( item:is_weapon() or item:is_outfit() ) and b ~= false ) or b == true
end

function set_item_always_ungroupable( obj, flag )
  obj:get_inventory_item().always_ungroupable = flag
end


--отладочные обёртки для глобальных функций level.enable_input и level.disable_input
local enable_input_orig = level.enable_input
level.enable_input = function()
	--log1("level.enable_input")
	--log1(debug.traceback())
	enable_input_orig()
end
local disable_input_orig = level.disable_input
level.disable_input = function()
	--log1("level.disable_input")
	--log1(debug.traceback())
	disable_input_orig()
end


-- http://www.amk-team.ru/forum/index.php?showtopic=6185&p=945289
weapon_states = {
  idle      = global_flags.eIdle,
  fire      = global_flags.eFire,
  fire2     = global_flags.eFire2,
  reload    = global_flags.eReload,
  showing   = global_flags.eShowing,
  hiding    = global_flags.eHiding,
  hidden    = global_flags.eHidden,
  misfire   = global_flags.eMisfire,
  mag_empty = global_flags.eMagEmpty,
  switch    = global_flags.eSwitch,
}


-- показывает, что оружие находится в соостоянии поворота для приближенного
-- прицеливания. См. xr_3da\xrGame\Weapon.h:253
-- bool IsRotatingToZoom() const { return (m_fZoomRotationFactor < 1.f); }
function wpn_IsRotatingToZoom( wpn )
  return wpn:get_weapon().zoom_rotation_factor < 1
end


function zero_all_af_effects( af )
  local af_obj = af:get_artefact()
  for _, k in ipairs({
    "bleeding_restore_speed",
    "health_restore_speed",
    "power_restore_speed",
    "satiety_restore_speed",
  }) do
    af_obj[ k ] = 0
  end

  local iitem = af:get_inventory_item()
  ASSERT( iitem, "%s not an inventory_item", af:name() )
  for _, k in ipairs({
    "psy_health_restore_speed",
    "radiation_restore_speed",
  }) do
    iitem[ k ] = 0
  end

  local af_imm = af.immunities
  for _, k in ipairs({
    "chemical_burn_immunity",
    "burn_immunity",
    "explosion_immunity",
    "fire_wound_immunity",
    "radiation_immunity",
    "shock_immunity",
    "strike_immunity",
    "telepatic_immunity",
    "wound_immunity",
  }) do
    af_imm[ k ] = 1
  end
end


function set_outfit_protection( obj, k, v )
  local outfit = obj:get_outfit()
  outfit[ k ] = v
end

function zero_outfit_protection( obj )
  local outfit = obj:get_outfit()
  for _, k in ipairs({   
    "burn_protection",
    "chemical_burn_protection",
    "fire_wound_protection",
    "explosion_protection",
    "radiation_protection",
    "shock_protection",
    "strike_protection",
    "telepatic_protection",
    "wound_protection",
  }) do
    outfit[ k ] = 0
  end
end


function set_outfit_power_loss( obj, val )
  obj:get_outfit().power_loss = val
end


function set_outfit_additional_inventory_weight( obj, val )
  obj:set_additional_max_walk_weight( val )
end

function set_outfit_additional_inventory_weight2( obj, val )
  obj:set_additional_max_weight( val )
end


function set_inv_item_cost( obj, cost )
  obj:get_inventory_item().cost = cost
end


function get_inv_item_slot( obj )
  return obj:get_inventory_item().slot
end

function set_inv_item_slot( obj, slot )
  obj:get_inventory_item().slot = slot
end


-- http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=1002890
function normal_triangle( element ) -- нормаль треугольника
  local n = vector():set( 0, 0, 0 )
  local a = level.get_tri_vertex1( element )
  local b = level.get_tri_vertex2( element )
  local c = level.get_tri_vertex3( element )
  n.x = ( ( b.z - a.z ) * ( c.y - a.y ) ) - ( ( b.y - a.y ) * ( c.z -a.z ) )
  n.y = ( ( b.x - a.x ) * ( c.z - a.z ) ) - ( ( b.z - a.z ) * ( c.x -a.x ) )
  n.z = ( ( b.y - a.y ) * ( c.x - a.x ) ) - ( ( b.x - a.x ) * ( c.y -a.y ) )
  return n:normalize()
end


-- возвращает имя кости по ее индексу
-- http://xray-engine.org/index.php?title=X-Ray_extensions
function get_bone_name_by_id( obj, bone_id )
  return obj:get_bone_name( bone_id )
end


-- возвращает level_vertex_id по позиции на уровне
function level.vertex_id_by_pos( ... )
  return level.vertex_id( ... )
end


-- запускает эффектор шатания камеры с заданными параметрами
function level.add_cam_effector3( total_time, amplitude, period_number, power )
  level.set_ce_time( total_time )
  level.set_ce_amplitude( amplitude )
  level.set_ce_period_number( period_number )
  level.set_ce_power( power )
  level.add_ce()
end


-- Взято отсюда: https://github.com/davidm/lua-bit-numberlua
function bit_rshift( a, disp )
  if disp < 0 then return bit_lshift( a, -disp ) end
  return math.floor( a % 2^32 / 2^disp )
end

function bit_lshift( a, disp )
  if disp < 0 then return rshift( a, -disp ) end
  return ( a * 2^disp ) % 2^32
end

--=================================[CUIScriptWnd Extension]=====================================
-- Вызов обычный, как и в AddCallback, но после последнего аргумента можно передавать множество дополнительных.
function CUIScriptWnd:Connect(name, event, func, ...)
	local args = {...}
	return self:AddCallback( name, event, function() func(unpack(args)) end )
end
--==============================================================================================

_G.GetIconParams = function (section)
    if section~=nil and section~=""
        and sys_ini:section_exist(section)
        and sys_ini:line_exist(section, "inv_grid_x")
    then
        return {x = sys_ini:r_u32(section, "inv_grid_x") *50,
                y = sys_ini:r_u32(section, "inv_grid_y") *50,
                w = sys_ini:r_u32(section, "inv_grid_width") *50,
                h = sys_ini:r_u32(section, "inv_grid_height") *50,
                g = sys_ini:r_u32(section, "icon_group", 0) }
    end
    return {x=0, y=0, w=1, h=1, g=0}
end

local IsBlocked = false
_G.BlockUIDescr = function( b )
	if b == nil then
		return IsBlocked
	else
		IsBlocked = b
	end
end

local ShiftHold = false
_G.ShiftPressed = function( b )
	if b == nil then
		return ShiftHold
	else
		ShiftHold = b
	end
end

_G.sys_ini = system_ini()
_G.kScreen = math.min( (1024/768) / (device().width/device().height), 1 )
_G.isWideScreen = _G.kScreen <= 0.85


-- class 'CUIScriptWnd'
local wnd_id        = 1
local registered_windows = {}
CUIScriptWnd.AddCallbackEx = function ( self, ui_name, ui_event, func, ... )
	local id = self.__CUIScriptWnd_id
	if id == nil then
		id = wnd_id
		wnd_id = wnd_id + 1
		self.__CUIScriptWnd_id = id
		registered_windows[ id ] = {}
		registered_windows[ id ]["__window"] = self
	end
	if registered_windows[ id ][ ui_name ] == nil then
		registered_windows[ id ][ ui_name ] = {}
	end
	registered_windows[ id ][ ui_name ][ ui_event ] = { ... }

	self:AddCallback( ui_name, ui_event,
		function ( i )
			local t = registered_windows[ i ]
			if t then
				local wnd = t["__window"]
				local p = t[ ui_name ][ ui_event ]
				func( wnd, unpack( p ) )
			else
				log( "[CUIScriptWnd]: ignore callback for unregistered window %s: ui_name = %s, ui_event = %s",
					i, ui_name, ui_event )
			end
		end,
	id )
end
CUIScriptWnd.ClearCallbacks = function ( self )
	local id = self.__CUIScriptWnd_id
	if id == nil then
	--	log("~ CUIScriptWnd.ClearCallbacks : __CUIScriptWnd_id not found" )
	else
		if self.__reg_childs then
			for i, v in ipairs( self.__reg_childs ) do
				registered_windows[ v ]["__window"] = nil
				registered_windows[ v ] = nil
			end
			self.__reg_childs = nil
		end
		registered_windows[ id ]["__window"] = nil
		registered_windows[ id ] = nil
	end
--	log("CUIScriptWnd.ClearCallbacks [%s]: registered windows count [%d]", tostring(id), table.size(registered_windows) )
end
CUIScriptWnd.RegisterChild = function( self, child )
	if child.__CUIScriptWnd_id == nil then return end

	local id = self.__CUIScriptWnd_id
	if id == nil then
		id = wnd_id
		wnd_id = wnd_id + 1
		self.__CUIScriptWnd_id = id
		registered_windows[ id ] = {}
		registered_windows[ id ]["__window"] = self
	--	log("CUIScriptWnd.RegisterChild: parent window has no __CUIScriptWnd_id" )
	end

	if self.__reg_childs == nil then
		self.__reg_childs = {}
	end
	table.insert( self.__reg_childs, child.__CUIScriptWnd_id )
end


-- 'Возвращение строки
function to_string(val)
	if val==nil then
		return val
	end
	return tostring(val)
end
-- 'Возвращение цифры
function to_number(val)
	if val==nil then
		return val
	end
	return tonumber(val)
end

-- 'Дистанция до обьекта.
function distance_to_object(obj,type,dist_value,absence_parent)
	local currert_distance=db.actor:position():distance_to(obj:position())
	if ((type=="<=" and currert_distance<=dist_value) or (type=="<" and currert_distance<dist_value) or (type==">=" and currert_distance>=dist_value) or (type==">" and currert_distance>dist_value) or (type=="==" and currert_distance<dist_value)) and ((absence_parent==nil) or (absence_parent~=nil and absence_parent==false and obj:parent()~=nil) or (absence_parent~=nil and absence_parent==true and obj:parent()==nil)) then 
		return true
	end
	return false
end


-- переносим акторские неквестовые вещи в ящик с указанным story_id
function transfer_to_box(box_sid)
local box = level_object_by_sid(box_sid)
if box then
		for i = 0, db.actor:object_count() - 1 do
			local obj = db.actor:object(i)
			if obj and alife():object(obj:id()) then
				local sect = obj:section()
				if obj and not (sys_ini:line_exist(sect, "quest_item") and sys_ini:r_bool(sect, "quest_item")) 
					and not string.find(sect, "device_pda") 
					and not string.find(sect, "device_torch") 
					and not string.find(sect, "separator") 
					and not string.find(sect, "bolt") then

				db.actor:transfer_item(obj, box)
	      end
	   end
	end
    end
end

-- переносим все вещи из ящика с указанным story_id
function transfer_from_box( box_sid )
	local box = level_object_by_sid(box_sid)
	if not box then return end

	local cnt = box:inv_box_count()
	for i=0, cnt-1 do
		local obj = box:object_from_inv_box(i)
		-- есть ли объект
		if obj then
			local sect = obj:section()
			-- передаем предмет
			box:transfer_item(obj, db.actor)
		end
	end
end


-------
-- получить список id вещей лежащих в ящике
-- {id1, id2, ...} enum_box_items(game_object box)
-------
function enum_box_items(box)
	local ids = {}
	for i=0, box:inv_box_count()-1 do
		local obj = box:object_from_inv_box(i)
		table.insert(ids, obj:id())
	end
	return ids
end

-- получить машину, в которой сидит ГГ
function get_actor_car()
	local holder = db.actor:get_holder()
	if holder and holder:is_car() then return holder end
	return false
end

prefetch("lua_extension") --/#+# подключение модуля расширений Lua
prefetch("lua_helper") --/#+# подключение модуля 'общих' хелп-функций